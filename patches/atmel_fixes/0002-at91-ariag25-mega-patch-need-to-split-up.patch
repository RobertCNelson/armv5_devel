From f2526aa52e54d5b957d02c40c77276651d1dac51 Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Mon, 1 Apr 2013 15:01:16 -0500
Subject: [PATCH 2/2] at91: ariag25 mega patch: need to split up

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 arch/arm/boot/dts/at91sam9g25ek.dts |    7 ++
 arch/arm/boot/dts/at91sam9x5.dtsi   |   39 ++++++++
 arch/arm/boot/dts/at91sam9x5ek.dtsi |    6 +-
 arch/arm/mach-at91/at91sam9x5.c     |    5 +
 drivers/dma/at_hdmac.c              |    2 +
 drivers/mmc/host/atmel-mci.c        |    1 +
 drivers/mmc/host/of_mmc_spi.c       |   28 ++++--
 drivers/rtc/Kconfig                 |    3 +-
 drivers/rtc/rtc-at91rm9200.c        |  177 +++++++++++++++++++++++++++++++++--
 drivers/tty/serial/atmel_serial.c   |   19 +++-
 10 files changed, 264 insertions(+), 23 deletions(-)

diff --git a/arch/arm/boot/dts/at91sam9g25ek.dts b/arch/arm/boot/dts/at91sam9g25ek.dts
index c5ab16f..8c6c77f 100644
--- a/arch/arm/boot/dts/at91sam9g25ek.dts
+++ b/arch/arm/boot/dts/at91sam9g25ek.dts
@@ -13,4 +13,11 @@
 / {
 	model = "Atmel AT91SAM9G25-EK";
 	compatible = "atmel,at91sam9g25ek", "atmel,at91sam9x5ek", "atmel,at91sam9x5", "atmel,at91sam9";
+
+	rtc {
+		compatible = "atmel,at91sam9x5-rtc";
+
+		reg = <0xfffffeb0 0x40>;
+		interrupts = <1 4 7>;
+	};
 };
diff --git a/arch/arm/boot/dts/at91sam9x5.dtsi b/arch/arm/boot/dts/at91sam9x5.dtsi
index 347b438..a6be48a 100644
--- a/arch/arm/boot/dts/at91sam9x5.dtsi
+++ b/arch/arm/boot/dts/at91sam9x5.dtsi
@@ -343,6 +343,32 @@
 					};
 				};
 
+				i2c0 {
+					pinctrl_i2c0: i2c0-0 {
+						/* no pull-up and no multi-drive (open drain) */
+						atmel,pins =
+							<0 30 0x1 0x0	/* PA30 periph A TWD0 pin */
+							 0 31 0x1 0x0>;	/* PA31 periph A TWCK0 pin */
+					};
+				};
+
+				i2c1 {
+					pinctrl_i2c1: i2c1-0 {
+						atmel,pins =
+							<2 0 0x3 0x0	/* PC0 periph C TWD1 pin */
+							 2 1 0x3 0x0>;	/* PC1 periph C TWCK1 pin */
+					};
+				};
+
+				i2c2 {
+					pinctrl_i2c2: i2c2-0 {
+						atmel,pins =
+							<1 4 0x2 0x0	/* PB4 periph B TWD2 pin */
+							 1 5 0x2 0x0>;	/* PB5 periph B TWCK1 pin */
+					};
+				};
+
+
 				spi0 {
 					pinctrl_spi0: spi0-0 {
 						atmel,pins =
@@ -489,6 +515,8 @@
 				interrupts = <9 4 6>;
 				#address-cells = <1>;
 				#size-cells = <0>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_i2c0>;
 				status = "disabled";
 			};
 
@@ -498,6 +526,8 @@
 				interrupts = <10 4 6>;
 				#address-cells = <1>;
 				#size-cells = <0>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_i2c1>;
 				status = "disabled";
 			};
 
@@ -507,6 +537,8 @@
 				interrupts = <11 4 6>;
 				#address-cells = <1>;
 				#size-cells = <0>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_i2c2>;
 				status = "disabled";
 			};
 
@@ -645,4 +677,11 @@
 		#size-cells = <0>;
 		status = "disabled";
 	};
+
+	rtc {
+		compatible = "atmel,at91sam9x5-rtc";
+		reg = <0xfffffeb0 0x40>;
+		interrupts = <1 4 7>;
+		status = "disabled";
+	};
 };
diff --git a/arch/arm/boot/dts/at91sam9x5ek.dtsi b/arch/arm/boot/dts/at91sam9x5ek.dtsi
index 09f5e66..baeeabc 100644
--- a/arch/arm/boot/dts/at91sam9x5ek.dtsi
+++ b/arch/arm/boot/dts/at91sam9x5ek.dtsi
@@ -65,9 +65,9 @@
 				status = "okay";
 			};
 
-			i2c2: i2c@f8018000 {
-				status = "okay";
-			};
+			/* i2c2: i2c@f8018000 { */
+			/*	status = "okay"; */
+			/*}; */
 
 			pinctrl@fffff400 {
 				mmc0 {
diff --git a/arch/arm/mach-at91/at91sam9x5.c b/arch/arm/mach-at91/at91sam9x5.c
index a200d8a..69510e1 100644
--- a/arch/arm/mach-at91/at91sam9x5.c
+++ b/arch/arm/mach-at91/at91sam9x5.c
@@ -227,6 +227,8 @@ static struct clk_lookup periph_clocks_lookups[] = {
 	CLKDEV_CON_DEV_ID("usart", "f8020000.serial", &usart1_clk),
 	CLKDEV_CON_DEV_ID("usart", "f8024000.serial", &usart2_clk),
 	CLKDEV_CON_DEV_ID("usart", "f8028000.serial", &usart3_clk),
+	CLKDEV_CON_DEV_ID("usart", "f8040000.serial", &uart0_clk),
+	CLKDEV_CON_DEV_ID("usart", "f8044000.serial", &uart1_clk),
 	CLKDEV_CON_DEV_ID("t0_clk", "f8008000.timer", &tcb0_clk),
 	CLKDEV_CON_DEV_ID("t0_clk", "f800c000.timer", &tcb0_clk),
 	CLKDEV_CON_DEV_ID("mci_clk", "f0008000.mmc", &mmc0_clk),
@@ -234,6 +236,9 @@ static struct clk_lookup periph_clocks_lookups[] = {
 	CLKDEV_CON_DEV_ID("dma_clk", "ffffec00.dma-controller", &dma0_clk),
 	CLKDEV_CON_DEV_ID("dma_clk", "ffffee00.dma-controller", &dma1_clk),
 	CLKDEV_CON_DEV_ID("pclk", "f0010000.ssc", &ssc_clk),
+	CLKDEV_CON_DEV_ID("spi_clk", "f0000000.spi", &spi0_clk),
+	CLKDEV_CON_DEV_ID("spi_clk", "f0004000.spi", &spi1_clk),
+	CLKDEV_CON_DEV_ID("adc_clk", "f804c000.adc", &adc_clk),
 	CLKDEV_CON_DEV_ID(NULL, "f8010000.i2c", &twi0_clk),
 	CLKDEV_CON_DEV_ID(NULL, "f8014000.i2c", &twi1_clk),
 	CLKDEV_CON_DEV_ID(NULL, "f8018000.i2c", &twi2_clk),
diff --git a/drivers/dma/at_hdmac.c b/drivers/dma/at_hdmac.c
index 6e13f26..1237e0d 100644
--- a/drivers/dma/at_hdmac.c
+++ b/drivers/dma/at_hdmac.c
@@ -14,6 +14,8 @@
  * found on AT91SAM9263.
  */
 
+#define DEBUG
+
 #include <linux/clk.h>
 #include <linux/dmaengine.h>
 #include <linux/dma-mapping.h>
diff --git a/drivers/mmc/host/atmel-mci.c b/drivers/mmc/host/atmel-mci.c
index d5cdf06..85d46bd 100644
--- a/drivers/mmc/host/atmel-mci.c
+++ b/drivers/mmc/host/atmel-mci.c
@@ -2350,6 +2350,7 @@ static int __init atmci_probe(struct platform_device *pdev)
 			dev_err(&pdev->dev, "platform data not available\n");
 			return PTR_ERR(pdata);
 		}
+		pdev->dev.platform_data = pdata;
 	}
 
 	irq = platform_get_irq(pdev, 0);
diff --git a/drivers/mmc/host/of_mmc_spi.c b/drivers/mmc/host/of_mmc_spi.c
index d720b5e..c06abb2 100644
--- a/drivers/mmc/host/of_mmc_spi.c
+++ b/drivers/mmc/host/of_mmc_spi.c
@@ -64,6 +64,11 @@ static int of_mmc_spi_get_cd(struct device *dev)
 	return of_mmc_spi_read_gpio(dev, CD_GPIO);
 }
 
+static int of_mmc_spi_get_cd_inv(struct device *dev)
+{
+	return ! of_mmc_spi_read_gpio(dev, CD_GPIO);
+}
+
 static int of_mmc_spi_get_ro(struct device *dev)
 {
 	return of_mmc_spi_read_gpio(dev, WP_GPIO);
@@ -140,17 +145,26 @@ struct mmc_spi_platform_data *mmc_spi_get_pdata(struct spi_device *spi)
 			oms->alow_gpios[i] = true;
 	}
 
-	if (gpio_is_valid(oms->gpios[CD_GPIO]))
-		oms->pdata.get_cd = of_mmc_spi_get_cd;
+	if (gpio_is_valid(oms->gpios[CD_GPIO])) {
+		if (of_get_property(np, "cd-inverted", NULL))
+			oms->pdata.get_cd = of_mmc_spi_get_cd_inv;
+		else
+			oms->pdata.get_cd = of_mmc_spi_get_cd;
+	}
 	if (gpio_is_valid(oms->gpios[WP_GPIO]))
 		oms->pdata.get_ro = of_mmc_spi_get_ro;
 
-	oms->detect_irq = irq_of_parse_and_map(np, 0);
-	if (oms->detect_irq != 0) {
-		oms->pdata.init = of_mmc_spi_init;
-		oms->pdata.exit = of_mmc_spi_exit;
-	} else {
+	if (of_get_property(np, "np-removable", NULL))
+		oms->pdata.caps |= MMC_CAP_NONREMOVABLE;
+	else if (of_get_property(np, "broken-cd", NULL))
 		oms->pdata.caps |= MMC_CAP_NEEDS_POLL;
+	else {
+		oms->detect_irq = irq_of_parse_and_map(np, 0);
+		if (oms->detect_irq != 0) {
+			oms->pdata.init = of_mmc_spi_init;
+			oms->pdata.exit = of_mmc_spi_exit;
+		} else
+			oms->pdata.caps |= MMC_CAP_NEEDS_POLL;
 	}
 
 	dev->platform_data = &oms->pdata;
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 79fbe38..e5539f14 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -970,7 +970,8 @@ config RTC_DRV_AT91RM9200
 	help
 	  Driver for the internal RTC (Realtime Clock) module found on
 	  Atmel AT91RM9200's and some  AT91SAM9 chips. On AT91SAM9 chips
-	  this is powered by the backup power supply.
+	  this is powered by the backup power supply (such as a small
+	  coin cell battery). Includes the AT91SAM9x5 family.
 
 config RTC_DRV_AT91SAM9
 	tristate "AT91SAM9x/AT91CAP9 RTT as RTC"
diff --git a/drivers/rtc/rtc-at91rm9200.c b/drivers/rtc/rtc-at91rm9200.c
index 0a9f27e..1f1028d 100644
--- a/drivers/rtc/rtc-at91rm9200.c
+++ b/drivers/rtc/rtc-at91rm9200.c
@@ -10,6 +10,7 @@
  *
  *	Based on sa1100-rtc.c by Nils Faerber
  *	Based on rtc.c by Paul Gortmaker
+ *	Extended to AT91SAM9x5 family by Douglas Gilbert 20121114
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
@@ -28,6 +29,8 @@
 #include <linux/ioctl.h>
 #include <linux/completion.h>
 #include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 
 #include <asm/uaccess.h>
 
@@ -43,9 +46,35 @@
 static DECLARE_COMPLETION(at91_rtc_updated);
 static unsigned int at91_alarm_year = AT91_RTC_EPOCH;
 static void __iomem *at91_rtc_regs;
-static int irq;
+static int at91_rtc_irq;
 static u32 at91_rtc_imr;
 
+static bool a_broken_imr;
+static int shadow_rtc_imr;
+
+struct at91_rtc_pdata {
+	bool has_broken_imr;
+};
+
+struct at91_rtc_pdata at91rm9200_config = {
+	.has_broken_imr = false,
+};
+
+struct at91_rtc_pdata at91sam9x5_config = {
+	.has_broken_imr = true,
+};
+
+#ifdef CONFIG_OF
+static const struct of_device_id at91rm9200_rtc_dt_ids[] = {
+	{ .compatible = "atmel,at91rm9200-rtc", .data = &at91rm9200_config },
+	{ .compatible = "atmel,at91sam9x5-rtc", .data = &at91sam9x5_config },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, at91rm9200_rtc_dt_ids);
+#else
+#define at91rm9200_rtc_dt_ids NULL
+#endif	/* CONFIG_OF */
+
 /*
  * Decode time/date into rtc_time structure
  */
@@ -263,6 +292,110 @@ static const struct rtc_class_ops at91_rtc_ops = {
 	.alarm_irq_enable = at91_rtc_alarm_irq_enable,
 };
 
+#ifdef CONFIG_OF
+
+static const struct at91_rtc_pdata * __init at91_rtc_get_driver_data(
+                                        struct platform_device *pdev)
+{
+        if (pdev->dev.of_node) {
+                const struct of_device_id *match;
+                match = of_match_node(at91rm9200_rtc_dt_ids,
+				      pdev->dev.of_node);
+                if (!match)
+                        return NULL;
+                return match->data;
+        }
+        return &at91rm9200_config;
+}
+
+/*
+ * Initialize and install RTC driver [OF]
+ */
+static int __init at91_rtc_probe(struct platform_device *pdev)
+{
+	struct rtc_device *rtc;
+	struct resource *regs;
+	const struct at91_rtc_pdata *pdp;
+	int ret = 0;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs) {
+		dev_err(&pdev->dev, "no mmio resource defined\n");
+		return -ENXIO;
+	}
+
+	at91_rtc_irq = platform_get_irq(pdev, 0);
+	if (at91_rtc_irq < 0) {
+		dev_err(&pdev->dev, "no irq resource defined\n");
+		return -ENXIO;
+	}
+
+	at91_rtc_regs = ioremap(regs->start, resource_size(regs));
+	if (!at91_rtc_regs) {
+		dev_err(&pdev->dev, "failed to map registers, aborting.\n");
+		return -ENOMEM;
+	}
+
+	at91_rtc_write(AT91_RTC_CR, 0);
+	at91_rtc_write(AT91_RTC_MR, 0);		/* 24 hour mode */
+
+	/* Disable all interrupts */
+	at91_rtc_write(AT91_RTC_IDR, AT91_RTC_ACKUPD | AT91_RTC_ALARM |
+					AT91_RTC_SECEV | AT91_RTC_TIMEV |
+					AT91_RTC_CALEV);
+	at91_rtc_imr = 0;
+
+	ret = request_irq(at91_rtc_irq, at91_rtc_interrupt,
+				IRQF_SHARED,
+				"at91_rtc", pdev);
+	if (ret) {
+		printk(KERN_ERR "at91_rtc: IRQ %d already in use.\n",
+				at91_rtc_irq);
+		return ret;
+	}
+
+	/* cpu init code should really have flagged this device as
+	 * being wake-capable; if it didn't, do that here.
+	 */
+	if (!device_can_wakeup(&pdev->dev))
+		device_init_wakeup(&pdev->dev, 1);
+
+	rtc = rtc_device_register(pdev->name, &pdev->dev,
+				&at91_rtc_ops, THIS_MODULE);
+	if (IS_ERR(rtc)) {
+		free_irq(at91_rtc_irq, pdev);
+		return PTR_ERR(rtc);
+	}
+	platform_set_drvdata(pdev, rtc);
+
+	printk(KERN_ERR "at91_rtc_probe: started, irq=%d\n", at91_rtc_irq);
+	printk(KERN_ERR "at91_rtc_probe: base=0x%x\n", (unsigned int)at91_rtc_regs);
+	printk(KERN_INFO "AT91 Real Time Clock driver.\n");
+	return 0;
+}
+
+/*
+ * Disable and remove the RTC driver
+ */
+static int __exit at91_rtc_remove(struct platform_device *pdev)
+{
+	struct rtc_device *rtc = platform_get_drvdata(pdev);
+
+	/* Disable all interrupts */
+	at91_rtc_write(AT91_RTC_IDR, AT91_RTC_ACKUPD | AT91_RTC_ALARM |
+					AT91_RTC_SECEV | AT91_RTC_TIMEV |
+					AT91_RTC_CALEV);
+	at91_rtc_imr = 0;
+	free_irq(at91_rtc_irq, pdev);
+
+	rtc_device_unregister(rtc);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+#else	/* non-device-tree (OF) */
+
 /*
  * Initialize and install RTC driver
  */
@@ -278,8 +411,8 @@ static int __init at91_rtc_probe(struct platform_device *pdev)
 		return -ENXIO;
 	}
 
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
+	at91_rtc_irq = platform_get_irq(pdev, 0);
+	if (at91_rtc_irq < 0) {
 		dev_err(&pdev->dev, "no irq resource defined\n");
 		return -ENXIO;
 	}
@@ -299,11 +432,13 @@ static int __init at91_rtc_probe(struct platform_device *pdev)
 					AT91_RTC_CALEV);
 	at91_rtc_imr = 0;
 
-	ret = request_irq(irq, at91_rtc_interrupt,
+	at91_rtc_imr = 0;
+
+	ret = request_irq(at91_rtc_irq, at91_rtc_interrupt,
 				IRQF_SHARED,
 				"at91_rtc", pdev);
 	if (ret) {
-		dev_err(&pdev->dev, "IRQ %d already in use.\n", irq);
+		dev_err(&pdev->dev, "IRQ %d already in use.\n", at91_rtc_irq);
 		return ret;
 	}
 
@@ -316,7 +451,7 @@ static int __init at91_rtc_probe(struct platform_device *pdev)
 	rtc = rtc_device_register(pdev->name, &pdev->dev,
 				&at91_rtc_ops, THIS_MODULE);
 	if (IS_ERR(rtc)) {
-		free_irq(irq, pdev);
+		free_irq(at91_rtc_irq, pdev);
 		return PTR_ERR(rtc);
 	}
 	platform_set_drvdata(pdev, rtc);
@@ -337,7 +472,7 @@ static int __exit at91_rtc_remove(struct platform_device *pdev)
 					AT91_RTC_SECEV | AT91_RTC_TIMEV |
 					AT91_RTC_CALEV);
 	at91_rtc_imr = 0;
-	free_irq(irq, pdev);
+	free_irq(at91_rtc_irq, pdev);
 
 	rtc_device_unregister(rtc);
 	platform_set_drvdata(pdev, NULL);
@@ -345,6 +480,8 @@ static int __exit at91_rtc_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#endif	/* CONFIG_OF */
+
 #ifdef CONFIG_PM
 
 /* AT91RM9200 RTC Power management control */
@@ -360,7 +497,7 @@ static int at91_rtc_suspend(struct device *dev)
 	at91_rtc_bkpimr = at91_rtc_imr & (AT91_RTC_ALARM|AT91_RTC_SECEV);
 	if (at91_rtc_bkpimr) {
 		if (device_may_wakeup(dev)) {
-			enable_irq_wake(irq);
+			enable_irq_wake(at91_rtc_irq);
 		} else {
 			at91_rtc_write(AT91_RTC_IDR, at91_rtc_bkpimr);
 			at91_rtc_imr &= ~at91_rtc_bkpimr;
@@ -373,7 +510,7 @@ static int at91_rtc_resume(struct device *dev)
 {
 	if (at91_rtc_bkpimr) {
 		if (device_may_wakeup(dev)) {
-			disable_irq_wake(irq);
+			disable_irq_wake(at91_rtc_irq);
 		} else {
 			at91_rtc_imr |= at91_rtc_bkpimr;
 			at91_rtc_write(AT91_RTC_IER, at91_rtc_bkpimr);
@@ -393,6 +530,26 @@ static const struct dev_pm_ops at91_rtc_pm = {
 #define at91_rtc_pm_ptr	NULL
 #endif
 
+#ifdef CONFIG_OF
+
+static struct platform_driver at91_rtc_driver = {
+        .probe          = at91_rtc_probe,
+        .remove         = __exit_p(at91_rtc_remove),
+        .driver         = {
+                .name   = "at91_rtc",
+                .owner  = THIS_MODULE,
+                .of_match_table = at91rm9200_rtc_dt_ids,
+                .pm     = at91_rtc_pm_ptr,
+        },
+};
+
+static int __init at91_rtc_init(void)
+{
+	return platform_driver_register(&at91_rtc_driver);
+}
+
+#else	/* non-device-tree (OF) */
+
 static struct platform_driver at91_rtc_driver = {
 	.remove		= __exit_p(at91_rtc_remove),
 	.driver		= {
@@ -407,6 +564,8 @@ static int __init at91_rtc_init(void)
 	return platform_driver_probe(&at91_rtc_driver, at91_rtc_probe);
 }
 
+#endif	/* CONFIG_OF */
+
 static void __exit at91_rtc_exit(void)
 {
 	platform_driver_unregister(&at91_rtc_driver);
diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c
index 3467462..1897008 100644
--- a/drivers/tty/serial/atmel_serial.c
+++ b/drivers/tty/serial/atmel_serial.c
@@ -1458,7 +1458,7 @@ static void atmel_of_init_port(struct atmel_uart_port *atmel_port,
 /*
  * Configure the port from the platform device resource info.
  */
-static void atmel_init_port(struct atmel_uart_port *atmel_port,
+static int atmel_init_port(struct atmel_uart_port *atmel_port,
 				      struct platform_device *pdev)
 {
 	struct uart_port *port = &atmel_port->uart;
@@ -1496,6 +1496,8 @@ static void atmel_init_port(struct atmel_uart_port *atmel_port,
 	/* for console, the clock could already be configured */
 	if (!atmel_port->clk) {
 		atmel_port->clk = clk_get(&pdev->dev, "usart");
+		if (IS_ERR(atmel_port->clk))
+			return 1;	/* peripheral clock not found */
 		clk_enable(atmel_port->clk);
 		port->uartclk = clk_get_rate(atmel_port->clk);
 		clk_disable(atmel_port->clk);
@@ -1511,6 +1513,7 @@ static void atmel_init_port(struct atmel_uart_port *atmel_port,
 	} else {
 		atmel_port->tx_done_mask = ATMEL_US_TXRDY;
 	}
+	return 0;
 }
 
 struct platform_device *atmel_default_console_device;	/* the serial console device */
@@ -1649,13 +1652,18 @@ static int __init atmel_console_init(void)
 		struct atmel_uart_data *pdata =
 			atmel_default_console_device->dev.platform_data;
 		int id = pdata->num;
+		int ret;
 		struct atmel_uart_port *port = &atmel_ports[id];
 
 		port->backup_imr = 0;
 		port->uart.line = id;
 
 		add_preferred_console(ATMEL_DEVICENAME, id, NULL);
-		atmel_init_port(port, atmel_default_console_device);
+		ret = atmel_init_port(port, atmel_default_console_device);
+		if (ret) {
+			pr_err("No peripheral clock for Atmel console ??\n");
+			return -EINVAL;
+		}
 		register_console(&atmel_console);
 	}
 
@@ -1786,7 +1794,12 @@ static int atmel_serial_probe(struct platform_device *pdev)
 	port->backup_imr = 0;
 	port->uart.line = ret;
 
-	atmel_init_port(port, pdev);
+	ret = atmel_init_port(port, pdev);
+	if (ret) {
+		ret = -EINVAL;
+		pr_err("peripheral clock not found for serial port\n");
+		goto err;
+	}
 
 	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
 	if (IS_ERR(pinctrl)) {
-- 
1.7.10.4

